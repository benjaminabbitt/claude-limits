<!-- DO NOT EDIT: This file is auto-generated by `scm run`. Edit source fragments instead. -->

# Communication Style

## Do
- State limitations immediately: "Cannot verify X without Y", "Approach has limitation Z", "Need clarification on A"
- Ask for help when: requirements ambiguous, multiple valid approaches, trade-offs need business input, uncertain about context
- Lead with key info → supporting details → rationale
- Cite sources: API docs, best practices, performance claims, security recs
- Verify tests pass before marking complete (TDD mandatory)

## Don't
- No sycophancy: no praise, enthusiasm markers, validation seeking
- No flattery/excessive politeness: skip "please"/"thank you", be direct
- No assumptions: ask if unsure, state when guessing

---

```yaml
# Security

## Core Principles
- No secrets in commits (use env vars)
- Validate external input
- Parameterized DB queries
- Keep deps updated
- Least privilege

## Review Checklist
- Input validation?
- Path traversal?
- Injection (SQL/cmd/XSS)?
- TOCTOU?
- Privilege escalation?
- Auth/authz correct?
- Secrets managed?
- Crypto correct?
- Data exposure?
- Deps scanned?
```

---

```yaml
# Code Quality Standards

## Philosophy
- **SOLID** - SRP, OCP, LSP, ISP, DIP
- **KISS** - Simple, straightforward solutions
- **YAGNI** - Build only when needed

## Principles
- Follow lang style guides
- Use type hints
- Self-documenting code > comments
- Document public APIs
- Small, focused functions
- Composition > inheritance

## Coupling/Cohesion
- Low coupling: minimal module dependencies
- High cohesion: group related functionality
- Single purpose per module/class

## Markers
- `TODO` - pending work
- `FIXME` - known bugs
- `NOTE` - explanations/warnings
- `HACK` - temp workarounds

## Performance
- Profile before optimizing
- Document perf requirements in tests
- Use appropriate data structures
- State complexity for non-trivial algorithms
- Consider memory allocation

## Clean Up
- Kill unused background processes
- Remove dead code, files, imports, vars
```

---

Here's the compressed version:

# 12-Factor App

Cloud-native SaaS methodology for portable, scalable apps.

## I. Codebase
1 repo per app, many deploys. Shared code → libraries via deps.

## II. Dependencies
Explicitly declare/isolate all deps. Never rely on system packages. Use manifest (go.mod, package.json, requirements.txt) + isolation tool.

## III. Config
Store in env vars. Config = deploy-varying data (creds, hosts). Never commit secrets. Strict separation from code.

## IV. Backing Services
Treat as attached resources (DBs, queues, caches, APIs). No distinction local vs third-party. Swap via config, not code.

## V. Build, Release, Run
Strictly separate:
- **Build**: Code → executable (compile, deps, assets)
- **Release**: Build + config. Unique ID, immutable
- **Run**: Execute in environment

Rollback = deploy previous release.

## VI. Processes
Stateless, share-nothing. Persist data in backing services. No sticky sessions—use Redis/Memcached for session state.

## VII. Port Binding
Self-contained, export HTTP via port. No runtime webserver injection. Routing layer maps hostname → port.

## VIII. Concurrency
Scale horizontally via process model. Different types (web, worker) for different workloads. Use OS process manager, not PID files.

## IX. Disposability
Fast startup, graceful shutdown. On SIGTERM: stop accepting, finish current, exit. Workers return jobs to queue. Design for sudden death.

## X. Dev/Prod Parity
Minimize gaps: time (hours not weeks), personnel (devs deploy), tools (same DBs/queues). Use Docker for local parity.

## XI. Logs
Event streams to stdout. App decoupled from log routing/storage. Environment handles capture → aggregators.

## XII. Admin Processes
Run one-off tasks (migrations, REPL) in identical environment. Same codebase/config as app. Ship admin code with app.

---

Here's my compressed version of the documentation guidelines:

---

# Documentation Guidelines

## README
- Read before acting
- Update when adding commands/features
- Keep current

## Ask Before Creating
- *.md files, planning/strategy/tracking docs, meta-docs
- **Exception:** README updates for new features OK

## Plan Files
- Location: `.plan/` directory
- Add `.plan/` to `.gitignore` (don't commit)
- Naming: `.plan/feature-name.md`

## Don't
- Add progress/refactoring comments in code
- Include change history/revision annotations in files
- Version control handles history via commits

## Do
- Suggest docs needs first
- Summarize in chat
- Update existing docs
- Create code/tests/config
- Write meaningful commits

---

# Problem-solving

**Principle:** Find root cause first. Fix at source.

## On Failing Functionality

1. **Find root cause** - No workarounds without asking
2. **Simple problem, complex fix?** - Stop, ask first
3. **Prompt options:** Fix properly (estimate), workaround (trade-offs), disable test (reason), alternatives
4. **Cost/benefit:** Pros/cons, tech debt, maintainability, time
5. **Document:** Record reasoning for chosen path

## Key Questions

- Fix properly vs workaround?
- Pros/cons?
- Tech debt impact?
- Disable test temporarily?
- Alternatives?

---

```yaml
# Pushback Guidelines

## When to Push Back
- Skip tests
- Add features w/o tests
- Ignore type hints
- Work around linting vs fix

## Response Pattern
1. State problem
2. Explain consequences
3. Suggest correct approach
4. Defer if insisted, note tech debt

## Feature Start Questions
- Acceptance criteria?
- Perf requirements?
- Error cases?
- Security implications?
- Logging needs?
- Dependencies?
- Test approach?
- Error messages?

## Component Design Questions
- Required dependencies?
- Dependency interface/protocol?
- Log context?
- Error conditions & messages?
```

---

# Git Practices

## Branching
- Create short-named branch before changes
- All task changes in single branch

## General
- Use `git log` for context
- Use `git rm` not `rm` for file removal

## Commits
- Straightforward, code-only messages
- **NEVER mention Claude/Anthropic/AI/"Generated with"**

## Breaking Changes
- <1.0 or new major: no backwards compat, clean deprecated code
- Post-1.0 minor/patch: discuss first

## Hooks: lefthook
- Config: `lefthook.yml`
- Pre-commit: lint, format, test (parallel)

## Pre-commit
- Run linters/formatters/tests
- Fix all issues before commit
- Auto-fix pre-commit errors

## Bypass
- Only WIP on feature branches
- Document with `--no-verify` + reason

---

# ast-grep: Structural Code Search & Replace

## When to Use
- Renaming functions/variables/types across codebase
- Refactoring API patterns
- Migrating deprecated patterns
- Finding structural code patterns
- Changes affecting many files

## Why Over Text Tools
- Structure-aware (AST, not text)
- Language-aware syntax understanding
- Safe refactoring (ignores strings/comments)
- Preserves formatting

## Basic Usage
```bash
ast-grep --pattern 'console.log($ARG)' --lang ts                    # Search
ast-grep --pattern 'OLD' --rewrite 'NEW' --lang ts                  # Replace
ast-grep --pattern 'OLD' --rewrite 'NEW' --interactive              # Review each
ast-grep --pattern 'OLD' --rewrite 'NEW' --lang py --update-all     # Apply in place
```

## Pattern Syntax
- `$NAME` — Named metavar, matches single AST node
- `$$$` — Matches zero+ nodes (variadic)
- `$_` — Wildcard (don't capture)
- Literal code matches exactly

## Examples
```bash
ast-grep -p 'getUserById($ID)' -r 'fetchUser($ID)' --lang ts
ast-grep -p 'from "old/path"' -r 'from "new/path"' --lang ts
ast-grep -p 'dangerousOp($ARGS)' -r 'try { dangerousOp($ARGS) } catch (e) { handleError(e) }' --lang ts
ast-grep -p 'createUser($NAME, $EMAIL, true)' -r 'createUser($NAME, $EMAIL)' --lang ts
```

## Rule Files (Complex Patterns)
```yaml
id: no-console-log
language: typescript
rule:
  pattern: console.log($$$ARGS)
fix: "logger.debug($$$ARGS)"
```
```bash
ast-grep scan --rule rules/no-console-log.yaml
```

## Workflow
1. Test pattern (no `--update-all`)
2. Review with `--interactive`
3. Apply with `--update-all`
4. Run tests
5. Commit

## Supported Languages
TypeScript, JavaScript, Python, Rust, Go, Java, C, C++, etc.

## Installation
```bash
brew install ast-grep          # macOS
cargo install ast-grep --locked # cargo
npm install -g @ast-grep/cli    # npm
```

---

# just - Command Runner

- Define common tasks in justfile (e.g., `just test`, `just lint`, `just run`)
- Language-agnostic task runner
- Use `git rev-parse --show-toplevel` for repo root (TOP)
- Base paths on TOP
- Create target for commands used 3+ times
- Document purpose, caveats, requirements, prerequisites

## Cross-Platform

- Maintain `justfile.nix`, `justfile.windows`
- Use platform_justfile pattern for correct import
- Sync changes between platform files when feasible
- Minimize platform differences

---

# TDD Workflow

## Cycle
1. **Red**: Write failing test first - verify fails correctly, good isolation
2. **Green**: Minimal code to pass - no extras
3. **Refactor**: Keep green, apply SOLID, dedupe, use existing libs, improve names

## Integration Tests
- Run actual binaries
- Tag slow tests
- Clean up after

## Naming
`test_<action>_<condition>_<result>`
- Python: snake_case
- C#/Java/JS: camelCase
- Prioritize readability

## Organization
- Human readable
- Order by complexity: simple examples top, edge cases bottom
- Tests = documentation

---

# Golang Development

## Environment
- Go version in go.mod
- Testing: stdlib `testing`, godog (Gherkin acceptance)
- Quality: golangci-lint, gofmt/goimports
- Logging: zap

## Test Structure
- Unit: `*_test.go` (co-located)
- Integration: `tests/integration/*_test.go` or build tags
- Acceptance: `tests/acceptance/features/*.feature`

## Testing
- Testify suites for shared setup (not single tests)
- gomock for mocks (generate via just)

## Patterns

**Logging (zap)**
```go
// logmsg/messages.go - const UserCreated = "user_created"
logger.Info(logmsg.UserCreated, zap.String("username", username))
```

**Error constants**
```go
// errmsg/messages.go - const DivideByZero = "cannot divide by zero"
return 0, errors.New(errmsg.DivideByZero)
```

**IoC**
```go
func NewUserService(repo UserRepository, logger *zap.Logger) *UserService { ... }
func NewUserServiceDefault(db *Database) *UserService { ... }  // nolint:unused
```